import 'dart:collection';

import 'package:flutter_flavorizr_extended/src/exception/existing_flavor_dimensions_exception.dart';
import 'package:flutter_flavorizr_extended/src/exception/malformed_resource_exception.dart';
import 'package:flutter_flavorizr_extended/src/parser/models/config/android.dart';
import 'package:flutter_flavorizr_extended/src/parser/models/flavorizr.dart';
import 'package:flutter_flavorizr_extended/src/parser/models/flavors/android/build_config_field.dart';
import 'package:flutter_flavorizr_extended/src/parser/models/flavors/android/res_value.dart';
import 'package:flutter_flavorizr_extended/src/processors/commons/string_processor.dart';

class AndroidBuildGradleProcessor extends StringProcessor {
  static const String androidEntryPoint = 'android {';
  static const String flavorDimensions = 'flavorDimensions';
  static const String beginFlavorDimensionsMarkup =
      '// ----- BEGIN flavorDimensions (autogenerated by flutter_flavorizr) -----';
  static const String endFlavorDimensionsMarkup =
      '// ----- END flavorDimensions (autogenerated by flutter_flavorizr) -----';
  static const String signingConfigs = 'signingConfigs {';

  AndroidBuildGradleProcessor({
    super.input,
    required super.config,
  });

  @override
  String execute() {
    // Use class-level constants
    final String androidEntryPoint =
        AndroidBuildGradleProcessor.androidEntryPoint;
    final String flavorDimensionsKeyword =
        AndroidBuildGradleProcessor.flavorDimensions;
    final String beginFlavorDimensionsMarkup =
        AndroidBuildGradleProcessor.beginFlavorDimensionsMarkup;
    final String endFlavorDimensionsMarkup =
        AndroidBuildGradleProcessor.endFlavorDimensionsMarkup;

    // Find positions of key elements in the input
    final int androidPosition = input!.indexOf(androidEntryPoint);
    final bool existingFlavorDimensions =
        input!.contains(flavorDimensionsKeyword);
    final int beginFlavorDimensionsMarkupPosition =
        input!.indexOf(beginFlavorDimensionsMarkup);
    final int endFlavorDimensionsMarkupPosition =
        input!.indexOf(endFlavorDimensionsMarkup);

    // Validate the presence of the Android entry point
    if (androidPosition < 0) {
      throw MalformedResourceException(input!);
    }

    // Find the end of the android block
    final int androidBlockEndPosition = _findMatchingClosingBrace(
        input!, androidPosition + androidEntryPoint.length);
    if (androidBlockEndPosition == -1) {
      throw MalformedResourceException(
          "No matching closing brace for android block.");
    }

    // Handle the scenario where flavor dimensions exist
    if (existingFlavorDimensions) {
      // Ensure both begin and end markers are present
      if (beginFlavorDimensionsMarkupPosition < 0 ||
          endFlavorDimensionsMarkupPosition < 0) {
        throw ExistingFlavorDimensionsException(input!);
      }

      // Modify the contents within the existing flavor dimensions block
      StringBuffer buffer = StringBuffer();

      // Append content before the flavor dimensions block (including the begin marker)
      buffer.write(input!.substring(
          0,
          beginFlavorDimensionsMarkupPosition +
              beginFlavorDimensionsMarkup.length));
      buffer.writeln(); // Ensure there's a newline for proper formatting

      // Append updated flavor dimensions content
      _appendFlavorsDimension(buffer);
      _appendFlavors(buffer);

      buffer.writeln('    $endFlavorDimensionsMarkup'); // Maintain indentation

      // Append the rest of the content after the flavor dimensions block
      buffer.write(input!.substring(endFlavorDimensionsMarkupPosition +
          endFlavorDimensionsMarkup.length));

      return buffer.toString();
    } else {
      // Flavor dimensions do not exist; proceed to insert them

      StringBuffer buffer = StringBuffer();

      // Append content before the end of the android block
      buffer.write(input!.substring(0, androidBlockEndPosition));

      buffer.writeln(); // Ensure there's a newline before inserting
      buffer.writeln('    $beginFlavorDimensionsMarkup');
      _appendFlavorsDimension(buffer);
      _appendFlavors(buffer);
      buffer.writeln('    $endFlavorDimensionsMarkup'); // Maintain indentation
      buffer.writeln(); // Ensure there's a newline after inserting

      // Append the closing brace of the android block
      buffer.write(input!.substring(androidBlockEndPosition));

      return buffer.toString();
    }
  }

  int _findMatchingClosingBrace(String input, int startPosition) {
    int braceCount =
        1; // Initialize to 1 since we've already found an opening brace
    for (int i = startPosition; i < input.length; i++) {
      if (input[i] == '{') {
        braceCount++;
      } else if (input[i] == '}') {
        braceCount--;
        if (braceCount == 0) {
          return i;
        }
      }
    }
    return -1; // Indicates mismatched braces
  }

  void _appendFlavorsDimension(StringBuffer buffer) {
    final flavorDimension =
        config.app?.android?.flavorDimensions ?? Android.kFlavorDimensionValue;

    // Use correct Gradle syntax for flavorDimensions
    buffer.writeln('    flavorDimensions "$flavorDimension"');
    buffer.writeln();
  }

  void _appendFlavors(StringBuffer buffer) {
    final flavorDimension =
        config.app?.android?.flavorDimensions ?? Android.kFlavorDimensionValue;

    buffer.writeln('    productFlavors {');

    config.androidFlavors.forEach((name, flavor) {
      buffer.writeln('        $name {');
      buffer.writeln('            dimension "$flavorDimension"');
      buffer.writeln(
          '            applicationId "${flavor.android?.applicationId}"');

      flavor.android?.customConfig.forEach((key, value) {
        buffer.writeln('            $key $value');
      });

      final Map<String, ResValue> resValues = LinkedHashMap.from({
        'app_name': ResValue(
          type: 'string',
          value: flavor.app.name,
        )
      })
        ..addAll(config.app?.android?.resValues ?? {})
        ..addAll(flavor.android?.resValues ?? {});
      resValues.forEach((key, res) {
        buffer.writeln(
            '            resValue "${res.type}", "$key", "${res.value}"');
      });

      final Map<String, BuildConfigField> buildConfigFields =
          LinkedHashMap.fromEntries([
        ...?config.app?.android?.buildConfigFields.entries,
        ...?flavor.android?.buildConfigFields.entries
      ]);
      buildConfigFields.forEach((key, res) {
        buffer.writeln(
            '            buildConfigField "${res.type}", "$key", ${res.wrappedValue}');
      });

      buffer.writeln('        }');
    });

    buffer.writeln('    }');
    buffer.writeln();
  }

  @override
  String toString() => 'AndroidBuildGradleProcessor';
}
